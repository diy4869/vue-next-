import { o as n, c as s, f as a, d as e } from './app.dabcecba.js'
const o =
    '{"title":"QA","description":"","frontmatter":{},"headers":[{"level":2,"title":"QA","slug":"qa"},{"level":2,"title":"浏览器渲染流程","slug":"浏览器渲染流程"},{"level":3,"title":"回流","slug":"回流"},{"level":3,"title":"重绘","slug":"重绘"},{"level":3,"title":"总结","slug":"总结"},{"level":2,"title":"vnode","slug":"vnode"}],"relativePath":"page/vnode.md","lastUpdated":1622888640443}',
  t = {},
  p = e(
    '<h2 id="qa"><a class="header-anchor" href="#qa" aria-hidden="true">#</a> QA</h2><ul><li>什么是<code>vnode</code>，为什么需要<code>vnode</code>？</li><li><code>vue-next</code>中，如何实现的<code>vnode</code>？</li></ul><h2 id="浏览器渲染流程"><a class="header-anchor" href="#浏览器渲染流程" aria-hidden="true">#</a> 浏览器渲染流程</h2><p>在说<code>vnode</code>之前，我们先了解下浏览器渲染流程，浏览器在拿到<code>HTML</code>的时候，会有以下步骤：</p><ul><li>解析<code>DOM</code>，生成<code>DOM tree</code>。</li><li>解析<code>CSS</code>，生成<code>CSS tree</code>。</li><li>合并<code>DOM tree</code>和<code>CSS tree</code>，生成<code>render tree</code>。</li><li>针对合并好的<code>render tree</code>去计算<code>layout</code>，并生成<code>layout tree</code>（这里是因为在<code>css</code>中，我们会通过<code>z-index</code>、<code>position</code>、<code>opacity</code>、<code>transform</code>、 <code>will-change</code>等一些属性，修改样式所产生的层级所触发的）。我们可以通过F12的<code>layer</code>，查看当前页面所产生的层，如果没有的话，可以通过<code>...</code>内有个<code>more tools</code>去找到<code>layer</code>进行查看。</li><li>至此，浏览器开始通过不断的<code>重绘（repaint）</code>和<code>回流（reflow）</code>开始渲染页面。</li><li>页面渲染完成。</li></ul>',
    5
  ),
  c = e(
    '<h3 id="回流"><a class="header-anchor" href="#回流" aria-hidden="true">#</a> 回流</h3><p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><p>引起回流：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><h3 id="重绘"><a class="header-anchor" href="#重绘" aria-hidden="true">#</a> 重绘</h3><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h3 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>上面主要关注的部分是回流和重绘这2个阶段，每次操作DOM的时候，所产生的渲染开销，一般是指这2部分。所以现代的框架通过<code>Vitrual DOM</code>的形式，来解决问题，也就是虚拟DOM。</p><p>上面详细内容可以去极客时间搜索<b>浏览器工作原理</b>与实践了解。</p><h2 id="vnode"><a class="header-anchor" href="#vnode" aria-hidden="true">#</a> vnode</h2><p>在了解了浏览器渲染流程之后，我们再来去看<code>vnode</code>，<code>vnode</code>定义了一种数据描述，它是对<code>DOM</code>节点的一种描述，如果我们对<code>DOM</code>进行操作，会产生渲染开销，当然这部分不是<code>js</code>所产生的，而是由浏览器渲染所产生的，所以就诞生了<code>Vitrual DOM</code>。</p><p>在<code>vue-next</code>中，是通过一个对象去描述的，代码在<code>packages/runtime-core/src/vnode.ts</code>，这是<code>vnode</code>的类型定义。</p><div class="language-ts"><pre><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">VNode<span class="token operator">&lt;</span>\n  HostNode <span class="token operator">=</span> RendererNode<span class="token punctuation">,</span>\n  HostElement <span class="token operator">=</span> RendererElement<span class="token punctuation">,</span>\n  ExtraProps <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">}</span>\n<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>\n  <span class="token comment">/**\n   * @internal\n   */</span>\n  __v_isVNode<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// 标记为vnode</span>\n\n  <span class="token comment">/**\n   * @internal\n   */</span>\n  <span class="token punctuation">[</span>ReactiveFlags<span class="token punctuation">.</span><span class="token constant">SKIP</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>\n\n  <span class="token keyword">type</span><span class="token operator">:</span> VNodeTypes\n  props<span class="token operator">:</span> <span class="token punctuation">(</span>VNodeProps <span class="token operator">&amp;</span> ExtraProps<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n  key<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n  ref<span class="token operator">:</span> VNodeNormalizedRef <span class="token operator">|</span> <span class="token keyword">null</span>\n  <span class="token comment">/**\n   * SFC only. This is assigned on vnode creation using currentScopeId\n   * which is set alongside currentRenderingInstance.\n   */</span>\n  scopeId<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n  <span class="token comment">/**\n   * SFC only. This is assigned to:\n   * - Slot fragment vnodes with :slotted SFC styles.\n   * - Component vnodes (during patch/hydration) so that its root node can\n   *   inherit the component&#39;s slotScopeIds\n   */</span>\n  slotScopeIds<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n  children<span class="token operator">:</span> VNodeNormalizedChildren\n  component<span class="token operator">:</span> ComponentInternalInstance <span class="token operator">|</span> <span class="token keyword">null</span>\n  dirs<span class="token operator">:</span> DirectiveBinding<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n  transition<span class="token operator">:</span> TransitionHooks<span class="token operator">&lt;</span>HostElement<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n\n  <span class="token comment">// DOM</span>\n  el<span class="token operator">:</span> HostNode <span class="token operator">|</span> <span class="token keyword">null</span>\n  anchor<span class="token operator">:</span> HostNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token comment">// fragment anchor</span>\n  target<span class="token operator">:</span> HostElement <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token comment">// teleport target</span>\n  targetAnchor<span class="token operator">:</span> HostNode <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token comment">// teleport target anchor</span>\n  staticCount<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token comment">// number of elements contained in a static vnode</span>\n\n  <span class="token comment">// suspense</span>\n  suspense<span class="token operator">:</span> SuspenseBoundary <span class="token operator">|</span> <span class="token keyword">null</span>\n  ssContent<span class="token operator">:</span> VNode <span class="token operator">|</span> <span class="token keyword">null</span>\n  ssFallback<span class="token operator">:</span> VNode <span class="token operator">|</span> <span class="token keyword">null</span>\n\n  <span class="token comment">// optimization only</span>\n  shapeFlag<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token comment">// 类型标记</span>\n  patchFlag<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token comment">// diff标记</span>\n  dynamicProps<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n  dynamicChildren<span class="token operator">:</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span>\n\n  <span class="token comment">// application root node only 只限于根节点</span>\n  appContext<span class="token operator">:</span> AppContext <span class="token operator">|</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span>\n</code></pre></div>',
    13
  )
t.render = function(e, o, t, l, r, d) {
  return (
    n(),
    s('div', null, [
      p,
      a(
        ' 以上具体内容参考[从输入URL开始建立前端知识体系](https://juejin.cn/post/6935232082482298911#heading-36) '
      ),
      c
    ])
  )
}
export default t
export { o as __pageData }
